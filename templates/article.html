<!-- Title, authors and abstract -->
<div class="subsection">
	<h2 class="paper-title"><!--Title--></h2>
	<strong><!--Reference--></strong>
	<br/>
	<a href="http://www.ncbi.nlm.nih.gov/pubmed/<!--PMID-->" target="_blank">[PubMed]</a>
	<a href="http://neurosynth.org/studies/<!--NeuroSynthID-->" target="_blank">[Neurosynth]</a>
	<a href="http://dx.doi.org/<!--DOI-->" target="_blank">[Full Text]</a>

	<div class="abstract subsection">
	<!--Abstract-->
	</div>
</div>

<!-- Metadata: MeSH descriptors, stereotaxic space and number of subjects -->
<div class="subsection">
<b style="font-family:sans-serif">Metadata</b>
<div style="padding:10px;border:1px solid lightGrey">
	<table style="width:100%">
	<tr>
	<td style="width:67%;vertical-align:top">
	<div>
		<b style="font-family:sans-serif">MeSH descriptors</b>
		<ul class="tag-list">
		</ul>
	</div>
	</td>
	<td>
	<div>
		<b style="font-family:sans-serif">Stereotaxic space</b>
		<br />
		<input onclick="logStereoSpace(this)" type="radio" name="stereoSpace" value="MNI" /> MNI <span id="MNI"></span>
		&nbsp;
		<input onclick="logStereoSpace(this)" type="radio" name="stereoSpace" value="Talairach" /> Talairach <span id="Talairach"></span>&nbsp;&nbsp;
	</div>

	<div class="subsection">
		<b style="font-family:sans-serif">Number of subjects</b>
		<br />
		<input onchange="logNSubjects(this)" type="text" id="nSubjects" style="width:3rem;text-align:right" />&nbsp;&nbsp;<span id="nSubjects"></span>
	</div>
	</td>
	</tr>
	</table>
</div>
</div>

<!-- Experiments: Locations tables, tags -->
<div class="subsection">
<b style="font-family:sans-serif">Experiments</b>
<div style="padding:5px;border:1px solid lightGrey">
	<div class="experiments">
	</div>
</div>
</div>

<!-- Discussion -->
<div class="subsection">
	<b style="font-family:sans-serif">Discussion</b>
	<div class="comments">
	</div>
	<textarea id="comment" cols=50 rows=5></textarea>
	<br />
	<button id="comment" onclick="logComment()">Post your comment</button>
	<span id="commentWarning"> <a onclick="login()">Log in</a> to comment</span>
</div>
<br />
<br />

<!-- HTML sanitizer -->
<script src="<!--ROOTDIR-->js/html-sanitizer-minified.js"></script>

<!-- Translucent Viewer -->
<script src="/js/three.min.js"></script>
<script src="/js/Detector.js"></script>
<script src="/js/threex/THREEx.screenshot.js"></script>
<script src="/js/threex/THREEx.FullScreen.js"></script>
<script src="/js/threex/THREEx.WindowResize.js"></script>
<script src='/js/SubdivisionModifier.js'></script>
<script src="/js/PLYLoader.js"></script>
<script src="/js/TrackballControls.js"></script>
<script src="/js/jquery-1.10.2.min.js"></script>

<script type="text/javascript">

var	meta=$.parseJSON('<!--Metadata-->');
var	exp=$.parseJSON('<!--Experiments-->');

var	tasks;
var	cognitive;
var	behavioural;
var	concept;
var	minVotes=3;	// Minimum number of votes a tag must have to be displayed	

init();

function updateArticle(iExp)
{
	if(arguments.length)
		console.log("[updateArticle] Login update at experiment "+iExp+" (Login: "+(loggedin?"Yes":"No")+")");
	else
		console.log("[updateArticle] Login update at article level (Login: "+(loggedin?"Yes":"No")+")");
	
	/*
		Article-level display
		---------------------
	*/
	if(loggedin)
	{
		// Metadata MeSH tags
		/*
		TO DO!
		if(exp[-1].tags)
			for(j=0;j<exp[-1].tags.length;j++)
			{
				var rtag=exp[-1].tags[j];
				rtag.agree=(rtag.agree)?parseInt(rtag.agree):0;
				rtag.disagree=(rtag.disagree)?parseInt(rtag.disagree):0;
				
				var	prevVote=findPreviousVoteByUser(-1,rtag);
				if(rtag.agree+rtag.disagree>=minVotes || prevVote!=0)
					addTagColor(iExp,rtag);
				else
					removeTagColor(iExp,rtag);
			}
		*/

		// Metadata stereotaxic space
		$("span#Talairach").show();
		$("span#MNI").show();
		$("input:radio[value='Talairach']").removeAttr('disabled');
		$("input:radio[value='MNI']").removeAttr('disabled');
		if(meta.stereo)
		{
			// own info
			var	prevSpace=findPreviousStereoSpaceByUser();
			if(prevSpace!=-1)
				$("input:radio[value='"+prevSpace+"']").attr('checked',true);

			// others info
			if(meta.stereo.Talairach+meta.stereo.MNI>=minVotes)
			{
				$("span#Talairach").html('('+meta.stereo.Talairach+')');
				$("span#MNI").html('('+meta.stereo.MNI+')');
			}
		}
		
		// Metadata number of subjects
		$("input#nSubjects").removeAttr('disabled');
		$("span#nSubjects").show();
		if(meta.nsubjects)
		{
			// own info
			var	nPrevNSubjects=findPreviousNSubjectsByUser();
			if(nPrevNSubjects!=-1)
				$("input#nSubjects").val(nPrevNSubjects);
			else
				$("input#nSubjects").val("");

			// others info
			if(meta.nsubjects.length>=minVotes)
			{
				var	i,x,min,max,n=meta.nsubjects.length;
				min=max=meta.nsubjects[0];
				for(i=0;i<n;i++){	x=parseInt(meta.nsubjects[i]);
									if(x<min) min=x;
									if(x>max) max=x;}
				if(min!=max)
					$("span#nSubjects").text("("+n+" values, min="+min+", max="+max+")");
				else
					$("span#nSubjects").text("("+n+" value"+((n>1)?"s)":")"));
			}
		}

		// Concept modal
		if($("#box"))
		{
			$('button#agree').removeAttr('disabled');
			$('button#disagree').removeAttr('disabled');
			$('.buttonsThing div#login-message').remove();
		}
		
		// Experiment table mark (global)
		$("div#tableAlert").hide();
		$("div#tableMark").show();
		
		// Discussion text area
		$("button#comment").removeAttr('disabled');
		$("span#commentWarning").hide();
	}
	else
	{
		// Metadata stereotaxic space
		$("input:radio[value='Talairach']").attr('disabled',true);
		$("input:radio[value='MNI']").attr('disabled',true);
		if(meta.stereo && (meta.stereo.Talairach+meta.stereo.MNI>=minVotes))
		{
			if(meta.stereo.Talairach>meta.stereo.MNI)
				$("input:radio[value='Talairach']").attr('checked',true);
			else
				$("input:radio[value='MNI']").attr('checked',true);
			$("span#Talairach").show();
			$("span#MNI").show();
			$("span#Talairach").html('('+meta.stereo.Talairach+')');
			$("span#MNI").html('('+meta.stereo.MNI+')');
		}
		else
		{
			$("input:radio[value='Talairach']").removeAttr('checked');
			$("input:radio[value='MNI']").removeAttr('checked');
			$("span#Talairach").hide();
			$("span#MNI").hide();
		}
		
		// Metadata number of subjects
		$("input#nSubjects").attr('disabled',true);
		if(meta.nsubjects && meta.nsubjects.length>=minVotes)
		{
			$("span#nSubjects").show();
			var	i,x,mean=0,min,max,n=meta.nsubjects.length;
			min=max=meta.nsubjects[0];
			for(i=0;i<n;i++){	x=parseInt(meta.nsubjects[i]);
								mean+=x/n;
								if(x<min) min=x;
								if(x>max) max=x;}
			$("input#nSubjects").val(mean.toFixed(1));
			if(min!=max)
				$("span#nSubjects").text("("+n+" values, min="+min+", max="+max+")");
			else
				$("span#nSubjects").text("("+n+" values)");
		}
		else
		{
			$("input#nSubjects").val("");
			$("span#nSubjects").hide();
		}

		// Experiment table mark (global)
		$("div#tableAlert").show();
		$("div#tableMark").hide();
		
		// Discussion text area
		$("button#comment").attr('disabled',true);
		$("span#commentWarning").show();
	}
	
	/*
		Experiment-level display
		------------------------
	*/
	if(arguments.length)
	{
		// Experiment table mark (specific)
		var prevMark=findPreviousTableMarkByUser(iExp);
		var markBadTable=exp[iExp].markBadTable;
		if(markBadTable && (markBadTable.bad+markBadTable.ok>=minVotes))
		{
			console.log("[updateArticle] iexp:",iExp,"markbad:",markBadTable);
			$(".experiment#"+iExp+":first span#Yes").html('('+markBadTable.ok+')');
			$(".experiment#"+iExp+":first span#No").html('('+markBadTable.bad+')');
			
			if(markBadTable.bad>markBadTable.ok)
				$(".experiment#"+iExp+":first #tableAlert ").html('<img src="/brainspell/img/alert.svg" style="height:0.8rem;display:inline;position:relative;top:0rem"/>This table may be incorrect');
			else
				$(".experiment#"+iExp+":first #tableAlert ").html("");
		}
		else
		{
			$(".experiment#"+iExp+":first span#Yes").html('');
			$(".experiment#"+iExp+":first span#No").html('');			
		}
		if(prevMark>-1)
		{
			$(".experiment#"+iExp+" input:radio[value='Yes']").attr('checked',prevMark==0);
			$(".experiment#"+iExp+" input:radio[value='No']").attr('checked',prevMark==1);
		}
		else
		{
			$(".experiment#"+iExp+" input:radio[value='Yes']").removeAttr('checked');
			$(".experiment#"+iExp+" input:radio[value='No']").removeAttr('checked');
		}
		
		// Experiment tags (specific)
		if(exp[iExp].tags)
			for(j=0;j<exp[iExp].tags.length;j++)
			{
				var rtag=exp[iExp].tags[j];
				rtag.agree=(rtag.agree)?parseInt(rtag.agree):0;
				rtag.disagree=(rtag.disagree)?parseInt(rtag.disagree):0;
				
				// Show tags only if there are at least minVotes votes,
				// or if the current user voted for it
				var	prevVote=findPreviousVoteByUser(iExp,rtag);
				if(rtag.agree+rtag.disagree>=minVotes || prevVote!=0)
					addTag(iExp,rtag);
				else
					removeTag(iExp,rtag);
			}
	}
}
function init()
{
	// Is JS enabled? Is it a touch device?
	var htmlTag = document.getElementsByTagName('html')[0];
	htmlTag.className = (htmlTag.className + ' ' || '') + 'hasJS';
	if ('ontouchstart' in document.documentElement)
		htmlTag.className = (htmlTag.className + ' ' || '') + 'isTouch';
	
	configureMetadata();
	configureExperiments();
	
	$.get(rootdir+"templates/cogatlas-tasks.html",function(data){tasks=data;console.log("[init] Tasks loaded");});
	$.get(rootdir+"templates/cogatlas-cognitive.html",function(data){cognitive=data;console.log("[init] Cognitive domains loaded");});
	$.get(rootdir+"templates/brainmap-behavioural.html",function(data){behavioural=data;console.log("[init] Behavioural domains loaded");});
	$.get(rootdir+"templates/concept.html",function(data){concept=data;console.log("[init] Concept loaded");});

	subscribeToLoginUpdates(updateArticle);
}

/*
---------------------------------------------------------
		  Configuration of the article page
---------------------------------------------------------
*/
function configureMetadata()
{
	/*
	Load and configure article-level metadata: stereotaxic space, mesh headings, number of subjects
	*/

	// Stereotaxic space
	/*
	*/
	
	// Number of subjects
	/*
	*/
	
	// MeSH descriptors
	var	metadata="";
	for(i=0;i<meta.meshHeadings.length;i++)
	{
		meta.meshHeadings[i].ontology="mesh";

		meta.meshHeadings[i].agree=(meta.meshHeadings[i].agree)?parseInt(meta.meshHeadings[i].agree):0;
		meta.meshHeadings[i].disagree=(meta.meshHeadings[i].disagree)?parseInt(meta.meshHeadings[i].disagree):0;
		var	rtag=meta.meshHeadings[i];
		var tag=$("<li>",{class:"tag"});
		if(meta.meshHeadings[i].majorTopic=="Y")
			tag.html('<b>'+rtag.name+'</b>');
		else
			tag.html(rtag.name);
		updateTagColor(tag,rtag);
		tag.click({rtag:rtag},function(e){openTagModal(-1,e.data.rtag)});
		$(".tag-list").append(tag);
	}
	
	// Discussion
	if(meta.comments)
	for(i=0;i<meta.comments.length;i++)
	{
		var comment=meta.comments[i].comment;
		var	user=meta.comments[i].user;
		var	time=new Date();
		time.setTime(meta.comments[i].time);
		$("div.comments").append("</p><a href='"+rootdir+"user/"+user+"'>"+user+"</a> ("+time.toLocaleString()+")<br \>");
		$("div.comments").append(comment);
		$("div.comments").append("</p><br \>");
	}
	
	console.log("[configureMetadata] metadata configured");
}
function configureExperiments()
{
	for(i=0;i<exp.length;i++)
	{
		if(exp[i].locations.length==0)
			continue;
		$(".experiments").append($('<div class="experiment" id="'+i+'">').load(rootdir+"templates/experiment.html",addExperiment(i)));
	}
	console.log("[configureExperiments] experiments configured");
}
function addExperiment(iExp)
{
	return function(responseText, textStatus, XMLHttpRequest){
		var title=(exp[iExp].title)?exp[iExp].title:"(Empty)";
		var caption=(exp[iExp].caption)?exp[iExp].caption:"(Empty)";
		
		// Add experiment legend
		$(".experiment#"+iExp+" .experiment-title").append(title);
		$(".experiment#"+iExp+" .experiment-caption").append(caption);

		// Add experiment locations to table
		var locations="";
		for(j=0;j<exp[iExp].locations.length;j++)
		{
			var coords=exp[iExp].locations[j].split(",");
			locations+="    <tr><td>"+coords[0]+"</td><td>"+coords[1]+"</td><td>"+coords[2]+"</td></tr>\n";
		}
		$(".experiment#"+iExp+" .experiment-locations .xyztable table").append(locations);
		
		// Add locations to metacoords view
		initMetaCoords(iExp);
				
		// Add ontologies
		$(".experiment#"+iExp+" .ontologies").append(addOntology(iExp,"tasks"));
		$(".experiment#"+iExp+" .ontologies").append(addOntology(iExp,"cognitive"));
		$(".experiment#"+iExp+" .ontologies").append(addOntology(iExp,"behavioural"));
		
		// Configure radio button groups for table marks
		$(".experiment#"+iExp+" input:radio[value='Yes']").attr('name',"radio"+iExp);
		$(".experiment#"+iExp+" input:radio[value='No']").attr('name',"radio"+iExp);
				
		// Adjust locations table height
		var padd,legendheight,xyzhdrheight,ontheight;
		padd=parseInt($('.experiment#'+iExp).css('padding-top'));
		legendheight=$('.experiment#'+iExp+' .experiment-title').innerHeight();
		legendheight+=$('.experiment#'+iExp+' .experiment-caption').innerHeight();
		xyzhdrheight=$('.experiment#'+iExp+' .xyzheader').innerHeight();
		ontheight=$('.experiment#'+iExp+' .ontologies').innerHeight();
		badTableHeight=$(".experiment#"+iExp+" input.badTable").innerHeight()+10;
		$('.experiment#'+iExp+' .xyztable').css({"height":300,"max-height":300-badTableHeight-padd});

		updateArticle(iExp);
		subscribeToLoginUpdates(function(){updateArticle(iExp)});
	}
}
function addOntology(iExp,ontology)
{
	var	str="";
	var ct="",cts=new Array({ontology:"tasks",title:"Cognitive Atlas Tasks"},{ontology:"cognitive",title:"Cognitive Atlas Cognitive Domains"},{ontology:"behavioural",title:"BrainMap Behavioural Domains"});
	var	cl;
	
	for(i=0;i<cts.length;i++)
		if(cts[i].ontology==ontology)
			ct=cts[i];

	str+='<div class="ontology" id="'+ontology+'" style="padding-left:5px;padding-bottom:5px">\n';
	str+='<div class="ontology-name"><span class="tag" style="top:-0.2em"><a onclick="openOntologyModal('+iExp+',\''+ontology+'\',\'+\');">+</a></span><b style="padding-left:4px;font-family:sans-serif">'+ct.title+'</b></div>\n';
	str+='<ul class="ontology-tags">\n';
	str+='</ul>\n';
	str+='</div>\n';

	return str;
}
function addTag(iExp,rtag)
{
	var prevTag=$("div.experiment#"+iExp+" div.ontology#"+rtag.ontology+" li:contains('"+rtag.name+"')").length;
	if(prevTag!=0)
		return;
		
	var tag=$("<li>",{class:'tag'});
	tag.html(rtag.name);
	tag.click({rtag:rtag},function(e){openTagModal(iExp,e.data.rtag)});
	updateTagColor(tag,rtag);
	$("div.experiment#"+iExp+" div.ontology#"+rtag.ontology+" ul").append(tag);
	return tag;
}
function removeTag(iExp,rtag)
{
	var prevTag=$("div.experiment#"+iExp+" div.ontology#"+rtag.ontology+" li:contains('"+rtag.name+"')").remove();
}
function updateTagColor(tag,rtag)
{
	if(tag.hasClass('green')) tag.removeClass('green');
	if(tag.hasClass('orange')) tag.removeClass('orange');
	if(tag.hasClass('red')) tag.removeClass('red');

	if(rtag.agree==0&&rtag.disagree==0)
		return;
	
	if(rtag.agree-rtag.disagree>0)
		tag.addClass('green');
	else
	if(rtag.agree-rtag.disagree<0)
		tag.addClass('red');
	else
		tag.addClass('orange');
}
function findTag(tags,name,ontology)
{
	var	j,found=0;
	var	ob;
	
	if(tags)
	for(j=0;j<tags.length;j++)
	{
		ob=tags[j];
		if((ob.name==name)&&(ob.ontology==ontology))
		{
			found=1;
			break;
		}
	}
	if(found==0)
		return 0;
	return ob;
}
function findPreviousVoteByUser(iExp,rtag)
{
	var found=0,vote=0;

	if(loggedin)
	{
		result=$.ajax({
			type: "GET",
			url: rootdir+"php/brainspell.php",
			data: {
				action:"get_log",
				type:"Vote",
				UserName:username,
				TagName:rtag.name,
				TagOntology:rtag.ontology,
				Experiment:iExp,
				PMID:"<!--PMID-->"
			},
			async: false
		}).done(function( msg ){
			var xml=$.parseXML(msg);
			//var	tagVote=parseInt($.parseJSON($(xml).find("TagVote").text()));
			var	tagVote=parseInt($(xml).find("TagVote").text());
			if(tagVote)
				vote=tagVote;
		});
	}
	return vote;
}
function findPreviousTableMarkByUser(iExp)
{
	var found=0,mark=-1;

	if(loggedin)
	{
		result=$.ajax({
			type: "GET",
			url: rootdir+"php/brainspell.php",
			data: {
				action:"get_log",
				type:"MarkTable",
				UserName:username,
				Experiment:iExp,
				PMID:"<!--PMID-->"
			},
			async: false
		}).done(function( msg ){
			console.log("[findPreviousTableMarkByUser] ",msg);
			var xml=$.parseXML(msg);
			var	markTable=$(xml).find("MarkTable").text();
			if(markTable)
				mark=parseInt(markTable);
		});
	}
	return mark;
}
function findPreviousStereoSpaceByUser()
{
	var found=0,resultSpace=-1;

	if(loggedin)
	{
		result=$.ajax({
			type: "GET",
			url: rootdir+"php/brainspell.php",
			data: {
				action:"get_log",
				type:"StereoSpace",
				UserName:username,
				PMID:"<!--PMID-->"
			},
			async: false
		}).done(function( msg ){
			console.log("[findPreviousStereoSpaceByUser] ",msg);
			var xml=$.parseXML(msg);
			var	space=$(xml).find("StereoSpace").text();
			if(space)
				resultSpace=space;
		});
	}
	return resultSpace;
}
function findPreviousNSubjectsByUser()
{
	var found=0,resultN=-1;

	if(loggedin)
	{
		result=$.ajax({
			type: "GET",
			url: rootdir+"php/brainspell.php",
			data: {
				action:"get_log",
				type:"NSubjects",
				UserName:username,
				PMID:"<!--PMID-->"
			},
			async: false
		}).done(function( msg ){
			console.log("[findPreviousNSubjectsByUser] ",msg);
			var xml=$.parseXML(msg);
			var	n=$(xml).find("NSubjects").text();
			if(n)
				resultN=n;
		});
	}
	return resultN;
}

/*
-----------------------------------------------------------------
		  Selection of tags
-----------------------------------------------------------------
*/
function openOntologyModal(iExp,ontology)
{
	if(ontology=="tasks")
		$('body').append(tasks);
	else if(ontology=="cognitive")
		$('body').append(cognitive);
	else if(ontology=="behavioural")
		$('body').append(behavioural);
	$('#light').show();
	$('#fade').show();
	$('#light #iExp').html(parseInt(iExp));
	$('#light #ontology').html(ontology);
	
	configureOntologyModal();
	resizeOntologyModal();
}
function closeOntologyModal(isOk)
{
	$('#light').css('display','none');
	$('#fade').css('display','none');
	$('.lightbox').remove();
}
function resizeOntologyModal()
{
	if($('#light'))
	{
		var	hall,htitle,padd;
		hall=$('#light .allThing').height();
		htitle=$('#light .titleThing').height();
		padd=parseInt($('#light .allThing').css('padding-top')); // even though 'padding' is used in the style text, paddingTop has to be used here because jquery doesn't handle shortcuts (like 'padding')
		val=2*padd;
		$('#light .myThing').css('height',(hall-htitle-val)+'px');
	}
}
function openTagModal(iExp,rtag)
{
	console.log("[openTagModal]");
	var	obj=0;
	
	if(iExp>-1)
		obj=findTag(exp[iExp].tags,rtag.name,rtag.ontology);
	else
		obj=findTag(meta.meshHeadings,rtag.name,rtag.ontology);
	if(obj)
		rtag=obj;
	$('body').append(concept);
	$('#box').show();
	$('#boxfade').show();
	$('#box #iExp').html(iExp);
	$('#box #ontology').html(rtag.ontology);
	
	configureTagModal(rtag);
	resizeTagModal();
}
function closeTagModal(vote)
{
	var	iExp=parseInt($('#box div#iExp').text());
	var	agree=parseInt($('#box span.agree').text());
	var disagree=parseInt($('#box span.disagree').text());
	var	name=$('#box h2.name').text();
	var ontology=$('#box #ontology').text();
	var	tag;
	
	if(vote!=0)	// vote can be -1, 0 or 1
	{
		// find the tag
		if(iExp>=0)	// iExp is >=0 for tables, =-1 for article-level tags
		{
			// check whether there were already any tags associated with this
			// experiment
			if(!(exp[iExp].tags))
				exp[iExp].tags=new Array;
				
			// check whether the currently voted tag was already among
			// the experiment's tags
			obj=findTag(exp[iExp].tags,name,ontology);
			if(obj)
			{
				rtag=obj;
				agree=rtag.agree;
				disagree=rtag.disagree;
			}
			else
			{
				var	rtag=new Object({"name":name,"ontology":ontology,"agree":0,"disagree":0});
				exp[iExp].tags.push(rtag);
				// addTag(iExp,rtag);
			}
			
			addTag(iExp,rtag); // addTag only adds the tag if it wasn't already added
		}
		else
			rtag=findTag(meta.meshHeadings,name,ontology);

		// save user vote
		var prevVote=findPreviousVoteByUser(iExp,rtag);
		logVote(iExp,rtag,vote);

		// compute total tag votes
		if(prevVote!=0)
		{
			if(vote!=prevVote)
			{
				rtag.agree+=vote;
				rtag.disagree-=vote;
			}
		}
		else
		{
			if(vote>0)
				rtag.agree=agree+1;
			else
				rtag.disagree=disagree+1;
		}
			
		// update tag display and save total tag votes (total agree/disagree stats)
		if(iExp>-1)
		{
			tag=$("div.experiment#"+iExp+" div.ontology#"+rtag.ontology+" li").filter(function(){return $(this).text()==rtag.name});
			updateTagColor(tag,rtag);
			tag=$(".classList span.tag").filter(function(){return $(this).text()==rtag.name});
			updateTagColor(tag,rtag);
		}
		else
		{
			tag=$(".tag-list li").filter(function(){return $(this).text()==rtag.name});
			updateTagColor(tag,rtag);
		}
	}
	$('#box').css('display','none');
	$('#boxfade').css('display','none');
	$('.box').remove();
}
function resizeTagModal()
{
	if($('#box'))
	{
		var	hall,htitle,padd;
		hall=$('#box .allThing').height();
		htitle=$('#box .titleThing').height();
		hbuttons=$('#box .buttonsThing').height();
		padd=parseInt($('#box .allThing').css('padding-top'));
		val=2*padd;
		$('#box .myThing').css('height',(hall-htitle-hbuttons-val)+'px');
	}
}
$(window).resize(function()
{
	resizeOntologyModal();
});

/*
---------------------------------------------------------
						 Save
---------------------------------------------------------
*/
function logVote(iExp,rtag,vote)
{
	console.log("[logVote] Log vote of user "+username);
	var	obj={	action:"add_log",
				type:"Vote",
				PMID:"<!--PMID-->",
				UserName:username,
				TagName:rtag.name,
				TagOntology:rtag.ontology,
				TagVote:vote,
				Experiment:iExp};
	$.get(rootdir+"php/brainspell.php",obj,function(data){
		console.log("[logVote]",data);
	});
}
function logMarkTable(sender)
{
	var	iExp=$(sender).closest("div.experiment").attr('id');
	var mark=$(".experiment#"+iExp+" input:radio[value='No']").attr('checked')?1:0;
	var	obj={	action:"add_log",
				type:"MarkTable",
				PMID:"<!--PMID-->",
				UserName:username,
				Mark:mark,
				Experiment:iExp};
	$.get(rootdir+"php/brainspell.php",obj,function(data){
		var out=$.parseJSON(data);
		exp[iExp].markBadTable={"bad":out.result.bad,"ok":out.result.ok};
		if(out.result.ok+out.result.bad>=minVotes)
		{
			$(".experiment#"+iExp+":first span#Yes").html('('+out.result.ok+')');
			$(".experiment#"+iExp+":first span#No").html('('+out.result.bad+')');
		}
	});
}
function logStereoSpace(sender)
{
	var	space=$(sender).val();
	console.log("[logStereoSpace] space",space);
	var	obj={	action:"add_log",
				type:"StereoSpace",
				PMID:"<!--PMID-->",
				UserName:username,
				StereoSpace:space};
	$.get(rootdir+"php/brainspell.php",obj,function(data){
		var out=$.parseJSON(data);
		console.log("[logStereoSpace] out",out.result);
		meta.stereo=out.result;
		if(meta.stereo.Talairach+meta.stereo.MNI>=minVotes)
		{
			$("span#Talairach").html('('+meta.stereo.Talairach+')');
			$("span#MNI").html('('+meta.stereo.MNI+')');
		}
	});
}
function logNSubjects(sender)
{
	var	nsubjects=$(sender).val();
	console.log("[logNSubjects] nsubjects",nsubjects);
	var	obj={	action:"add_log",
				type:"NSubjects",
				PMID:"<!--PMID-->",
				UserName:username,
				NSubjects:nsubjects};
	$.get(rootdir+"php/brainspell.php",obj,function(data){
		var out=$.parseJSON(data);
		console.log("[logNSubjects] out",out.result);

		meta.nsubjects=out.result;

		var	i,x,min,max,n=meta.nsubjects.length;
		min=max=meta.nsubjects[0];
		for(i=0;i<n;i++){	x=parseInt(meta.nsubjects[i]);
							if(x<min) min=x;
							if(x>max) max=x;}
		$("input#nSubjects").val(nsubjects);
		if(meta.nsubjects.length>=minVotes)
		{
			if(min!=max)
				$("span#nSubjects").text("("+n+" values, min="+min+", max="+max+")");
			else
				$("span#nSubjects").text("("+n+" value"+((n>1)?"s)":")"));
		}
	});
}
function logComment()
{
	var	content=html_sanitize($("textarea#comment").val());
	var	txt=JSON.stringify(content);
	console.log("[logComment]",content,txt);
	var	time=new Date().getTime();
	var	comment='{"comment":'+txt+',"user":"'+username+'","time":"'+time+'"}';
	console.log("[logComment] comment",comment);
	var	obj={	action:"add_log",
				type:"Comment",
				PMID:"<!--PMID-->",
				UserName:username,
				Comment:comment};
	$.get(rootdir+"php/brainspell.php",obj,function(data){
		console.log("[logComment]",data);
		var out=$.parseJSON(data);
		var	comment=$.parseJSON(out.result);
		var	time=new Date();
		time.setTime(comment.time);
		$("div.comments").append("</p><a href='"+rootdir+"user/"+username+"'>"+username+"</a> ("+time.toLocaleString()+")<br \>");
		$("div.comments").append(comment.comment);
		$("div.comments").append("</p><br \>");
		$("textarea").val("");
	});
}


// Translucent Viewer
var	mc=new Array();

function initMetaCoords(iExp)
{
	var	mc0=new Object();
	mc0.iExp=iExp;
	mc0.level=0.5;							// translucent
	mc0.container=$(".experiment#"+iExp+" div.metaCoords");
	mc.push(mc0);

	// Init render
	init_render(mc0);
	animate();

}
// init the scene
function init_render(mc0)
{
	// Init rendered
	if( Detector.webgl ){
		mc0.renderer = new THREE.WebGLRenderer({
			antialias				: true,	// to get smoother output
			preserveDrawingBuffer	: true	// to allow screenshot
		});
		mc0.renderer.setClearColor( 0xffffff, 0 );
	}else{
		mc0.renderer = new THREE.CanvasRenderer();
	}

	var container=mc0.container;
	var	width=container.width();
	var	height=container.height();
	mc0.renderer.setSize( width, height );
	container.append(mc0.renderer.domElement);

	// create a scene
	mc0.scene = new THREE.Scene();
	
	// create projector (for hit detection)
	mc0.projector = new THREE.Projector();
	mc0.renderer.domElement.addEventListener( 'mousedown', function(e){onDocumentMouseDown(e,mc0);}, false );

	// put a camera in the scene
	mc0.camera	= new THREE.PerspectiveCamera(40,width/height,25,50);
	mc0.camera.position.set(0, 0, 40);
	mc0.scene.add(mc0.camera);

	// create a camera control
	mc0.cameraControls=new THREE.TrackballControls(mc0.camera,mc0.container.get(0) )
	mc0.cameraControls.noZoom=true;

	// allow 'p' to make screenshot
	//THREEx.Screenshot.bindKey(renderer);
	
	// Add objects
	var	light	= new THREE.AmbientLight( Math.random() * 0xffffff );
	mc0.scene.add(light );
	var	light	= new THREE.DirectionalLight( Math.random() * 0xffffff );
	light.position.set( Math.random(), Math.random(), Math.random() ).normalize();
	mc0.scene.add(light );
	
	// Add locations
	var geometry = new THREE.SphereGeometry(1,10,10);
	for(j=0;j<exp[mc0.iExp].locations.length;j++)
	{
		var c=exp[mc0.iExp].locations[j].split(",");
		var sph = new THREE.Mesh( geometry, new THREE.MeshDepthMaterial({color: 0xff0000}));
		sph.position=new THREE.Vector3(c[0]*0.14,c[1]*0.14+3,c[2]*0.14-2);
		mc0.scene.add(sph);
	}

	// Load mesh (ply format)
	var oReq = new XMLHttpRequest();
	oReq.open("GET", "/data/lrh3.ply", true);
	oReq.responseType="text";
	oReq.onload = function(oEvent)
	{
		var tmp=this.response;
		mc0.material;
		mc0.geometry;
		var modifier = new THREE.SubdivisionModifier(1);
		
		mc0.material=new THREE.ShaderMaterial({
			uniforms: { 
				coeficient	: {
					type	: "f", 
					value	: 1.0
				},
				power		: {
					type	: "f",
					value	: 2
				},
				glowColor	: {
					type	: "c",
					value	: new THREE.Color('grey')
				},
			},
			vertexShader	: [ 'varying vec3	vVertexWorldPosition;',
								'varying vec3	vVertexNormal;',
								'varying vec4	vFragColor;',
								'void main(){',
								'	vVertexNormal	= normalize(normalMatrix * normal);',
								'	vVertexWorldPosition	= (modelMatrix * vec4(position, 1.0)).xyz;',
								'	gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
								'}',
								].join('\n'),
			fragmentShader	: [ 'uniform vec3	glowColor;',
								'uniform float	coeficient;',
								'uniform float	power;',
								'varying vec3	vVertexNormal;',
								'varying vec3	vVertexWorldPosition;',
								'varying vec4	vFragColor;',
								'void main(){',
								'	vec3 worldCameraToVertex= vVertexWorldPosition - cameraPosition;',
								'	vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;',
								'	viewCameraToVertex	= normalize(viewCameraToVertex);',
								'	float intensity		= pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);',
								'	gl_FragColor		= vec4(glowColor, intensity);',
								'}',
							].join('\n'),
			transparent	: true,
			depthWrite	: false,
		});
		
		mc0.geometry=new THREE.PLYLoader().parse(tmp);
		mc0.geometry.sourceType = "ply";
		
		modifier.modify(mc0.geometry);
		for(i=0;i<mc0.geometry.vertices.length;i++)
		{
			mc0.geometry.vertices[i].x*=0.14;
			mc0.geometry.vertices[i].y*=0.14;
			mc0.geometry.vertices[i].z*=0.14;
			mc0.geometry.vertices[i].y+=3;
			mc0.geometry.vertices[i].z-=2;
		}

		mc0.brainmesh=new THREE.Mesh(mc0.geometry,mc0.material);
		mc0.scene.add(mc0.brainmesh);
	};
	oReq.send();
}
// hit detection
function onDocumentMouseDown( event,mc0 ) {
	event.preventDefault();
	var	x,y;
	x= (event.clientX / event.target.clientWidth ) * 2 - 1;
	y=-(event.clientY / event.target.clientHeight ) * 2 + 1;

	console.log(x,y);
	for(j=0;j<exp[mc0.iExp].locations.length;j++)
	{
		var c=exp[mc0.iExp].locations[j].split(",");
		var vector = new THREE.Vector3(c[0],c[1],c[2]);
		mc0.projector.projectVector( vector, mc0.camera );
		console.log("m:",vector);
	}

	/*
	var raycaster = new THREE.Raycaster( mc0.camera.position, vector.sub( mc0.camera.position ).normalize() );
	var intersects = raycaster.intersectObjects( neurones );
	if ( intersects.length > 0 ) {
		controls.enabled = false;
		lastSelected=SELECTED = intersects[ 0 ].object;
		var intersects = raycaster.intersectObject( plane );
		offset.copy( intersects[ 0 ].point ).sub( plane.position );
		container.style.cursor = 'move';
	}
	*/
}

// animation loop
function animate()
{
	requestAnimationFrame( animate );
	for(i=0;i<mc.length;i++)
		render(mc[i]);
}
// render the scene
function render(mc0) {
	// update camera controls
	mc0.cameraControls.update();
	
	// actually render the scene
	mc0.renderer.render(mc0.scene,mc0.camera );
}
</script>
